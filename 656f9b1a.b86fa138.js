(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{143:function(e,r,t){"use strict";t.r(r),t.d(r,"frontMatter",(function(){return s})),t.d(r,"metadata",(function(){return l})),t.d(r,"rightToc",(function(){return d})),t.d(r,"default",(function(){return u}));var o=t(1),n=t(9),a=(t(0),t(164)),i=t(165),c=t(171),s={title:"Corridors",sidebar_label:"Corridors"},l={id:"guides/corridors",title:"Corridors",description:'import useBaseUrl from "@docusaurus/useBaseUrl";\r',source:"@site/docs\\guides\\corridors.md",permalink:"/ProceduralLevelGenerator/docs/next/guides/corridors",editUrl:"https://github.com/OndrejNepozitek/ProceduralLevelGenerator/tree/docusaurus/docs/guides/corridors.md",version:"next",sidebar_label:"Corridors",sidebar:"docs",previous:{title:"Different room descriptions",permalink:"/ProceduralLevelGenerator/docs/next/guides/different-room-descriptions"},next:{title:"Exporting generated layouts",permalink:"/ProceduralLevelGenerator/docs/next/guides/export"}},d=[{value:"Setup",id:"setup",children:[]},{value:"Adding corridors",id:"adding-corridors",children:[{value:"Using C# api",id:"using-c-api",children:[]},{value:"Using config files",id:"using-config-files",children:[]}]},{value:"Summary",id:"summary",children:[]},{value:"Results",id:"results",children:[{value:"Longer corridors",id:"longer-corridors",children:[]},{value:"L-shaped corridors",id:"l-shaped-corridors",children:[]}]}],p={rightToc:d};function u(e){var r=e.components,t=Object(n.a)(e,["components"]);return Object(a.b)("wrapper",Object(o.a)({},p,t,{components:r,mdxType:"MDXLayout"}),Object(a.b)("p",null,"There are currently 2 layout generators implemented. The first one generates layouts where neighbouring rooms are connected by doors. The second one, on the other hand, connects neighbouring rooms by corridors."),Object(a.b)("p",null,"In this tutorial, we will look into how to use the latter one."),Object(a.b)("h2",{id:"setup"},"Setup"),Object(a.b)("p",null,"In this tutorial, we will use a graph with 17 vertices codenamed ",Object(a.b)("em",{parentName:"p"},"Example1"),":"),Object(a.b)("img",{alt:"Graph",src:Object(i.a)("img/graphs/example1.svg")}),";",Object(a.b)("p",null,"We will use basic default shapes for rooms - a square and a rectangle - as they are not important for this tutorial."),Object(a.b)("h2",{id:"adding-corridors"},"Adding corridors"),Object(a.b)("p",null,"Corridors could be handled as normal rooms just with specific shapes. Hovewer, this approach is very slow as the total number of nodes in the graph becomes almost twice the original count (because map description needs connected graphs)."),Object(a.b)("p",null,"Instead, a completely different approach was implemented. The algoritm ignores corridor rooms and tries to get valid layouts consisting only of the ogirinal rooms without corridors. Hovewer, the algorithms does not place neighbouring rooms directly next to each other. It places such rooms in a way that they are specified number of units away from each other (this is reffered to be the ",Object(a.b)("em",{parentName:"p"},"offset of configuration spaces")," througnout this documentation). When a valid layout is found, the algorithm tries to greedily add corridor rooms."),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"Note:")," Currently, ",Object(a.b)("inlineCode",{parentName:"p"},"MapDescription")," class supports either not having corridors or adding a corridor between every pair of neighbouring rooms."),Object(a.b)("p",null,"In this tutorial, we will set the offset of non corridor neighbours to be equal to 1 and then set room shapes of corridor rooms to be 1x1 squares."),Object(a.b)("p",null,"Let's add corridors:"),Object(a.b)("h3",{id:"using-c-api"},"Using C# api"),Object(a.b)("p",null,"First we have to obtain the right instance of ",Object(a.b)("inlineCode",{parentName:"p"},"ChainBasedGenerator")," class:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-csharp"}),"var layoutGenerator = LayoutGeneratorFactory.GetChainBasedGeneratorWithCorridors<int>(new List<int>() { 1 });\n")),Object(a.b)("p",null,"And now we setup the map description:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-csharp"}),"var mapDescription = new MapDescription<int>();\n\n// Graph and default shapes are set here.\n\n// Setup corridor shapes\nvar corridorRoom = new RoomDescription(\n  GridPolygon.GetSquare(1),\n  new SpecificPositionsMode(new List<OrthogonalLine>()\n  {\n    new OrthogonalLine(new IntVector2(0, 0), new IntVector2(1, 0)),\n    new OrthogonalLine(new IntVector2(0, 1), new IntVector2(1, 1))\n  })\n);\n\nmapDescription.AddCorridorShapes(corridorRoom);\n\n// Enable corridors\nmapDescription.SetWithCorridors(true, new List<int>() { 1 });\n")),Object(a.b)("h3",{id:"using-config-files"},"Using config files"),Object(a.b)("p",null,"We first create a tutorial_corridors.yml file under the Resources/Rooms folder. Here we add room shapes for our corridors. We will create one shape - 1x1 square with doors on two opposite sides. "),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-yaml"}),"# Resources/Rooms/tutorial_corridors.yml\n\nname: tutorial_corridors\nroomDescriptions:\n  1-square:\n    shape: [[0,0], [0,1], [1,1], [1,0]]\n    doorMode: !SpecificPositionsMode\n      doorPositions: \n        - [[0,0], [1,0]]\n        - [[0,1], [1,1]]\n")),Object(a.b)("p",null,"Now we create the map description:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-yaml"}),"# Resources/Maps/tutorial_basic.yml\n\n# Rooms and passages are added here.\n\n# Default room shapes are added here.\n\ncorridors:\n  enable: true\n  offsets: [1]\n  corridorShapes:\n    -\n      setName: tutorial_corridors\n")),Object(a.b)("h2",{id:"summary"},"Summary"),Object(a.b)("p",null,"The map description is now ready to be used in a layout generator. You can find the full C# source code ",Object(a.b)("a",Object(o.a)({parentName:"p"},{href:"https://github.com/OndrejNepozitek/ProceduralLevelGenerator/blob/master/Sandbox/Examples/CorridorsExample.cs"}),"here")," and the config files ",Object(a.b)("a",Object(o.a)({parentName:"p"},{href:"https://github.com/OndrejNepozitek/ProceduralLevelGenerator/tree/master/Resources"}),"here"),"."),Object(a.b)("p",null,"Don't forget to use the appropriate layout generator if using the C# api."),Object(a.b)("h2",{id:"results"},"Results"),Object(a.b)(c.a,{cols:4,mdxType:"Gallery"},Object(a.b)(c.b,{src:"img/corridors/0.jpg",mdxType:"GalleryImage"}),Object(a.b)(c.b,{src:"img/corridors/1.jpg",mdxType:"GalleryImage"}),Object(a.b)(c.b,{src:"img/corridors/2.jpg",mdxType:"GalleryImage"}),Object(a.b)(c.b,{src:"img/corridors/3.jpg",mdxType:"GalleryImage"})),Object(a.b)("h3",{id:"longer-corridors"},"Longer corridors"),Object(a.b)("p",null,"We can also add some longer corridors:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-csharp"}),"var corridorRoom1x3 = new RoomTemplate(\n  GridPolygon.GetRectangle(1, 3),\n  new ManualDoorMode(new List<OrthogonalLine>()\n  {\n      new OrthogonalLine(new IntVector2(0, 0), new IntVector2(1, 0)),\n      new OrthogonalLine(new IntVector2(0, 3), new IntVector2(1, 3))\n  }),\n  new List<Transformation>() { Transformation.Identity, Transformation.Rotate90 }\n);\n")),Object(a.b)(c.a,{cols:4,mdxType:"Gallery"},Object(a.b)(c.b,{src:"img/corridors_longer/0.jpg",mdxType:"GalleryImage"}),Object(a.b)(c.b,{src:"img/corridors_longer/1.jpg",mdxType:"GalleryImage"}),Object(a.b)(c.b,{src:"img/corridors_longer/2.jpg",mdxType:"GalleryImage"}),Object(a.b)(c.b,{src:"img/corridors_longer/3.jpg",mdxType:"GalleryImage"})),Object(a.b)("h3",{id:"l-shaped-corridors"},"L-shaped corridors"),Object(a.b)("p",null,"We can also add some non-straight corridors:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-csharp"}),"var corridorRoomLShaped = new RoomTemplate(\n  new GridPolygonBuilder()\n    .AddPoint(0, 2)\n    .AddPoint(0, 3)\n    .AddPoint(3, 3)\n    .AddPoint(3, 0)\n    .AddPoint(2, 0)\n    .AddPoint(2, 2)\n    .Build(), \n  new ManualDoorMode(new List<OrthogonalLine>()\n  {\n    new OrthogonalLine(new IntVector2(0, 2), new IntVector2(0, 3)),\n    new OrthogonalLine(new IntVector2(2, 0), new IntVector2(3, 0))\n  }),\n  TransformationHelper.GetAllTransformations().ToList()\n);\n")),Object(a.b)(c.a,{cols:4,mdxType:"Gallery"},Object(a.b)(c.b,{src:"img/corridors_l/0.jpg",mdxType:"GalleryImage"}),Object(a.b)(c.b,{src:"img/corridors_l/1.jpg",mdxType:"GalleryImage"}),Object(a.b)(c.b,{src:"img/corridors_l/2.jpg",mdxType:"GalleryImage"}),Object(a.b)(c.b,{src:"img/corridors_l/3.jpg",mdxType:"GalleryImage"})),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},Object(a.b)("strong",{parentName:"p"},"Note:")," Even though the library can handle corridors of arbitrary shapes, you should not get too wild if you care about the performance of the algorithm. Please refer to the ",Object(a.b)("a",Object(o.a)({parentName:"p"},{href:"performance-tips#corridors"}),"Performance tips")," guide to see how to properly design corridors.")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},Object(a.b)("strong",{parentName:"p"},"Note:")," You can find the full C# source code ",Object(a.b)("a",Object(o.a)({parentName:"p"},{href:"https://github.com/OndrejNepozitek/ProceduralLevelGenerator/blob/master/Sandbox/Examples/CorridorsExample.cs"}),"here"),".")))}u.isMDXComponent=!0},164:function(e,r,t){"use strict";t.d(r,"a",(function(){return p})),t.d(r,"b",(function(){return m}));var o=t(0),n=t.n(o);function a(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function i(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,o)}return t}function c(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?i(Object(t),!0).forEach((function(r){a(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}function s(e,r){if(null==e)return{};var t,o,n=function(e,r){if(null==e)return{};var t,o,n={},a=Object.keys(e);for(o=0;o<a.length;o++)t=a[o],r.indexOf(t)>=0||(n[t]=e[t]);return n}(e,r);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)t=a[o],r.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(n[t]=e[t])}return n}var l=n.a.createContext({}),d=function(e){var r=n.a.useContext(l),t=r;return e&&(t="function"==typeof e?e(r):c({},r,{},e)),t},p=function(e){var r=d(e.components);return n.a.createElement(l.Provider,{value:r},e.children)},u={inlineCode:"code",wrapper:function(e){var r=e.children;return n.a.createElement(n.a.Fragment,{},r)}},b=Object(o.forwardRef)((function(e,r){var t=e.components,o=e.mdxType,a=e.originalType,i=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),p=d(t),b=o,m=p["".concat(i,".").concat(b)]||p[b]||u[b]||a;return t?n.a.createElement(m,c({ref:r},l,{components:t})):n.a.createElement(m,c({ref:r},l))}));function m(e,r){var t=arguments,o=r&&r.mdxType;if("string"==typeof e||o){var a=t.length,i=new Array(a);i[0]=b;var c={};for(var s in r)hasOwnProperty.call(r,s)&&(c[s]=r[s]);c.originalType=e,c.mdxType="string"==typeof e?e:o,i[1]=c;for(var l=2;l<a;l++)i[l]=t[l];return n.a.createElement.apply(null,i)}return n.a.createElement.apply(null,t)}b.displayName="MDXCreateElement"},165:function(e,r,t){"use strict";t.d(r,"a",(function(){return n}));t(170);var o=t(166);function n(e){var r=(Object(o.a)().siteConfig||{}).baseUrl,t=void 0===r?"/":r;if(!e)return e;return/^(https?:|\/\/)/.test(e)?e:e.startsWith("/")?t+e.slice(1):t+e}},166:function(e,r,t){"use strict";var o=t(0),n=t(48);r.a=function(){return Object(o.useContext)(n.a)}},168:function(e,r,t){var o=t(66),n=t(23);e.exports=function(e,r,t){if(o(r))throw TypeError("String#"+t+" doesn't accept regex!");return String(n(e))}},169:function(e,r,t){var o=t(2)("match");e.exports=function(e){var r=/./;try{"/./"[e](r)}catch(t){try{return r[o]=!1,!"/./"[e](r)}catch(n){}}return!0}},170:function(e,r,t){"use strict";var o=t(17),n=t(34),a=t(168),i="".startsWith;o(o.P+o.F*t(169)("startsWith"),"String",{startsWith:function(e){var r=a(this,e,"startsWith"),t=n(Math.min(arguments.length>1?arguments[1]:void 0,r.length)),o=String(e);return i?i.call(r,o,t):r.slice(t,t+o.length)===o}})},171:function(e,r,t){"use strict";t.d(r,"a",(function(){return c})),t.d(r,"b",(function(){return s}));var o=t(0),n=t.n(o),a=t(165);const i=e=>n.a.createElement("div",{style:{display:"inline-block",margin:2,overflow:"hidden",position:"relative",width:`calc(${100/e.cols}% - 4px)`}},e.children),c=e=>n.a.createElement("div",{style:{fontSize:"0px",margin:"20px 0"}},n.a.Children.map(e.children,r=>n.a.cloneElement(r,{cols:e.cols||4}))),s=e=>n.a.createElement("a",{href:Object(a.a)(e.src),target:"_blank"},n.a.createElement(i,{cols:e.cols},n.a.createElement("img",{src:Object(a.a)(e.src),alt:"result"})))}}]);